% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_exchange_rate_history.R
\name{get_exchange_rate_history}
\alias{get_exchange_rate_history}
\title{returns the exchange rate history of one or more currency pairs}
\usage{
get_exchange_rate_history(
  base_currency,
  price_currency,
  periodicity = "D",
  context = "A",
  fill_missing_dates = FALSE,
  max_lookback_days = 7,
  show_metadata = TRUE,
  filter = list(startPeriod = Sys.Date() - 370, endPeriod = Sys.Date() - 1,
    firstNObservations = NULL, lastNObservations = NULL)
)
}
\arguments{
\item{base_currency}{\emph{base currency}

\verb{scalar<character>} or \verb{vector<character>} // \strong{required}

Must be an 'ISO_4217' 3-Letter-Code for currencies. Can be either a single
value or multiple values in a vector. If multiple values are provided in
either \code{base_currency} or \code{price_currency}, all combinations will be
calculated.}

\item{price_currency}{\emph{price currency}

\verb{scalar<character>} or \verb{vector<character>} // \strong{required}

Must be an 'ISO_4217' 3-Letter-Code for currencies. Can be either a single
value or multiple values in a vector. If multiple values are provided in
either \code{base_currency} or \code{price_currency}, all combinations will be
calculated.}

\item{periodicity}{\emph{time related frequency/periodicity of data}

\verb{scalar<character>} //  \emph{default:} \code{D} for daily (\code{optional})

allowed values are either A, D, H, M, Q
\itemize{
\item \strong{A}...nnualy
\item \strong{D}...aily
\item \strong{H}...alf-Yearly
\item \strong{M}...onthly
\item \strong{Q}...uarterly
}}

\item{context}{\emph{in a period, what kind of value to chose}

\verb{scalar<character>} //  \emph{default:} \code{A} (\code{optional})

allowed values are either A or E:
\itemize{
\item \strong{A}...verage (can be used for any periodicity)
\item \strong{E}...nd-Of-Period (must not be used for daily periodicity)
}}

\item{fill_missing_dates}{\emph{add missing days at daily frequency?}

\verb{scalar<logical>} //  \emph{default:} \code{FALSE} (\code{optional})

If \code{periodicity}=\code{D}, there might be missing days because ECB will only publish
data on working days. TRUE fills the missing public holidays, weekends, ...
The values are taken from the most recent day before. If data is too old, you
might not want to use outdated exchange rates though. See: param \code{max_lookback_days}

If \code{periodicity}!=\code{D}, the parameter \code{fill_missing_dates} has no effect}

\item{max_lookback_days}{\emph{look back if missing for not more than X days}

\verb{scalar<numeric>} //  \emph{default:} \code{7} (\code{optional})

If \code{periodicity}=\code{D}, there might be missing days because ECB will only publish
data on working days. \code{fill_missing_dates}=TRUE fills the missing public holidays, weekends, ...
The values are taken from the most recent day before. If data is too old, you
might not want to use outdated exchange rates though. Set the maximum number of calender
days you want to go back with \code{max_lookback_days}. If you don't want to use
data of previous days, set this parameter to \code{0}

This parameter only has an effect if both \code{periodicity}=\code{D} and \code{fill_missing_dates}=\code{TRUE}}

\item{show_metadata}{\emph{return additional columns?}

\verb{scalar<logical>} //  \emph{default:} \code{TRUE} (\code{optional})

\itemize{
\item \strong{TRUE}: the requested periodicity, context and information about being
raw or calculated will be shown
\item \strong{FALSE}: only necessary columns will be returned
}}

\item{filter}{\emph{list of filter arguments to reduce data}

\code{list} //  \emph{default:} \code{ list( startPeriod = Sys.Date() - 370, endPeriod = Sys.Date() - 1,
                               firstNObservations = NULL, lastNObservations = NULL) } (\code{optional})

You can define the following arguments:
\itemize{
\item \strong{startPeriod} \verb{<Date>} first date of data.
If you set \code{periodicity}!=\code{D}, just choose one date in your starting period,
(e.g. the last day) it will be converted \emph{automatically} to:
\itemize{
\item YYYY for annual data (e.g. 2013)
\item YYYY-S[1-2] for semi-annual data (e.g. 2013-S1)
\item YYYY-Q[1-4] for quarterly data (e.g. 2013-Q1)
\item YYYY-MM for monthly data (e.g. 2013-01)
\item YYYY-MM-DD for daily data (e.g. 2013-01-01)
}
This means that the whole period will be covered, even if some days in that
period are before \code{startPeriod}. This is only relevant if \code{context} == \code{A} though
\item \strong{endPeriod} \verb{<Date>} last date of data.
If you set \code{periodicity}!=\code{D}, just choose one date in your starting period,
(e.g. the last day) it will be converted \emph{automatically} (see startPeriod)
\item \strong{firstNObservations} \verb{<numeric>} (\code{optional}) get the first N observations.
Must be \code{NULL} (=all observations) if \code{fill_missing_dates}=\code{TRUE}
\item \strong{lastNObservations} \verb{<character>} (\code{optional}) get the last N observations.
Must be \code{NULL} (=all observations) if \code{fill_missing_dates}=\code{TRUE}. Don't use
together with 'firstNObservations'
}

Set filter to NULL for no filters at all}
}
\value{
a \code{tibble} with the following columns
\itemize{
\item \strong{base_currency} \verb{<character>}⁠ (\href{https://www.iso.org/iso-4217-currency-codes.html}{ISO 4217}) 3-Letter currency code
\item \strong{price_currency} \verb{<character>}⁠ (\href{https://www.iso.org/iso-4217-currency-codes.html}{ISO 4217}) 3-Letter currency code
\item \strong{period} \verb{<character>} period of exchange rate
\itemize{
\item YYYY for annual data (e.g. 2013)
\item YYYY-S[1-2] for semi-annual data (e.g. 2013-S1)
\item YYYY-Q[1-4] for quarterly data (e.g. 2013-Q1)
\item YYYY-MM for monthly data (e.g. 2013-01)
\item YYYY-MM-DD for daily data (e.g. 2013-01-01)
}
If you want to transform this string to da date value, have a look at \code{\link[=sdmx_character_to_date]{sdmx_character_to_date()}}
\item \strong{value} \verb{<numeric>} the exchange rate, might be NA
}
and these columns if \code{show_metadata} = \code{TRUE}
\itemize{
\item \strong{periodicity} \verb{<character>} the requested periodicity A, D, H, M, Q
\item \strong{context} \verb{<character>} the requested context E or A
\item \strong{raw} \verb{<logical>}
\itemize{
\item \code{TRUE} if data was published as returned.
\item \code{FALSE} if cross-rate or inverse was calculated by the tool or missing data was filled
}

}
}
\description{
Time series in a deep table for each currency combination derived from defined
base and price currency. The \code{periodicity} and date-related filters can be
applied. This function is a wrapper around the official API and actually returns
error- and warning-messages instead of just a 404 error.
}
\details{
Central function for some other convenience-functions in this package..
\code{get_exchange_rate_history()} may return raw data or data calculated by this
package based on raw data. The ECB reference rates are usually updated at
around 16:00 CET every working day, except on TARGET closing days. They are
based on the daily concertation procedure between central banks across Europe,
which normally takes place around 14:10 CET. The reference rates are published
for information purposes only. Using the rates for transaction purposes is
strongly discouraged.

The exchange rate \eqn{USD/EUR = 1.1} with EUR as denominator (base currency)
shows that you'll get 1.1 USD-units (price currency) for 1 unit of EUR (base currency).
This package uses this exchange rate logic without arguing about direct or indirect
quotations. Also, there are no intraday, mid, ask or bid prices - only reference rates.

The actual amount of data is not limited but timeout is set to
\code{getOption("EXR.http.timeout", default = 30)} by this package. Therefore
you may set \code{options("EXR.http.timeout" = x)} to override the default value.
}
\examples{
# get semi annual data for the last year and a total of 8 currency combinations
EXR::get_exchange_rate_history(
  base_currency = c("EUR", "THB"),
  price_currency = c("EUR", "USD", "GBP", "THB"),
  periodicity = "H"
)

# get USD/EUR exchange rates for the last year,
# fill missing dates and look for missing values max 1 day
# so there won't be exchange rates on Sundays or subsequent holidays
EXR::get_exchange_rate_history(
  base_currency = "EUR",
  price_currency = "USD",
  periodicity = "D",
  fill_missing_dates = TRUE,
  max_lookback_days = 1
)

# get most recent EXR for USD/EUR - filtered directly by the API
# EUR/USD won't work that way because the API doesn't know that combination
EXR::get_exchange_rate_history(
  base_currency = "EUR",
  price_currency = "USD",
  show_metadata = FALSE,
  filter = list(
    endPeriod = Sys.Date(),
    lastNObservations = 1
  )
)

# get most recent EXR for EUR/USD and SGD/USD - filtered by the package
EXR::get_exchange_rate_history(
  base_currency = c("USD", "SGD"),
  price_currency = "EUR",
  fill_missing_dates = TRUE,
  filter = list(endPeriod = Sys.Date(), startPeriod = Sys.Date())
)

# trying to get an EXR for a holiday
EXR::get_exchange_rate_history(
  "EUR",
  "USD",
  filter = list(
    startPeriod = as.Date("2022-12-31"),
    endPeriod = as.Date("2022-12-31")
  )
)

}
